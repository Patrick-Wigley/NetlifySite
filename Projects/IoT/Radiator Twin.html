<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IoT Radiator Digital Twin</title>

  <link rel="stylesheet" href="../../styles/imgs.css">
  <link rel="stylesheet" href="../../styles/base.css">
  

  <!-- Syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <style>
    :root {
      --bg: #111;
      --bg-panel: #1a1a1a;
      --fg: #f1f1f1;
      --accent: #ff7b3a;
      --accent-soft: #ffb38a;
      --card-bg: #1f1f1f;
      --link-colour: #ff7b3a;
    }

    body {
      margin: 0;
      background: var(--bg);
      font-family: system-ui, sans-serif;
      color: var(--fg);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      width: 100%;
      padding: 1.5rem 0;
      background: var(--bg-panel);
      border-bottom: 2px solid var(--accent);
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 2.4rem;
      color: var(--accent);
    }

    header p {
      margin-top: 0.3rem;
      opacity: 0.8;
    }

    .main-wrapper {
      width: 100%;
      max-width: 900px;
      margin: 2rem auto;
      padding: 1.5rem;
      background: var(--bg-panel);
      border-radius: 16px;
      border: 1px solid #2a2a2a;
      box-shadow: 0 4px 16px rgba(0,0,0,0.4);
      overflow: hidden;
    }

    /* Ensure images never overflow */
    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 1rem auto;
    }

    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .image-box img {
      width: 100%;
      border-radius: 8px;
      cursor: pointer;
    }

    .section-title {
      font-size: 1.8rem;
      margin-top: 2rem;
      border-left: 5px solid var(--accent);
      padding-left: 0.75rem;
    }

    .timeline {
      margin-top: 1.5rem;
      border-left: 3px solid var(--accent);
      padding-left: 1.5rem;
    }

    .timeline-step {
      margin-bottom: 2rem;
      position: relative;
    }

    .timeline-step::before {
      content: "";
      position: absolute;
      left: -1.1rem;
      top: 0.3rem;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 0 6px var(--accent);
    }

    .timeline-step h3 {
      margin: 0;
      color: var(--accent-soft);
      font-size: 1.4rem;
    }

    .code-block p {
      text-align: center;
      text-decoration: underline;
    }

    footer {
      margin: 3rem 0 1rem;
      opacity: 0.7;
      text-align: center;
    }
  </style>
</head>

<body>
<header>
  <h1>Radiator Digital Twin</h1>
  <p>Real-time monitoring and simulation of my radiator and heating</p>
</header>

<div class="main-wrapper">
  <section>
    <h2 class="section-title">Overview</h2>
    <p>
      This project is a stepping stone for me into the world of Industry 4.0.
      This page highlights the foundations for the development of a radiator digital twin,
      from initially capturing real-time temperature data to ultimately displaying it in an immersive,
      simulated digital environment.
      <br><br>
      <a href="https://youtu.be/oLbgZInLvYg">YouTube video here ðŸ™‚</a>
    </p>
  </section>
</div>

<h2 class="section-title">The Project</h2>

<div class="main-wrapper">
  <section>
    <div class="timeline">
      <div class="timeline-step">
        <h3>1. Data Acquisition (Physical Components)</h3>
        <p>
          This project utilises inexpensive off-the-shelf devices.
          The sensor used is a
          <a href="https://thepihut.com/products/waterproof-ds18b20-digital-temperature-sensor-extras">
            DS18B20 digital temperature sensor
          </a>.
          It is waterproof (IP67), with a measuring range of -55Â°C to +125Â°C and Â±0.5Â°C accuracy
          between -10Â°C and +85Â°C.
          <br><br>
          The sensor is configurable via a One-Wire interface and can easily be deployed alongside
          multiple One-Wire sensors for sensor fusion.
          <br><br>
          The microcontroller (MCU) used is an ESP32 DevKit V1, featuring a dual-core processor
          with Wi-Fi and Bluetooth capabilities.
        </p>

        <div class="image-grid">
          <div class="image-box"><img src=" Radiator Twin Media/FullSetup.png"></div>
          <div class="image-box"><img src="Radiator Twin Media/SensorSituation.png"></div>
          <div class="image-box"><img src="Radiator Twin Media/Breadboard.png"></div>
        </div>

        <div id="imgModal" class="modal">
          <span class="close-btn">&times;</span>
          <img id="modalImg" class="modal-content" />
        </div>


        <p>
          The DS18B20 sensor has been retrofitted to the radiator in a consistent and suitable
          position to ensure stable readings.
        </p>
      </div>
    </div>
  </section>
</div>

<div class="main-wrapper">
  <section>
    <div class="timeline-step">
      <h3>2. Data Acquisition (Transmission)</h3>

      <h4>What the ESP32 is doing</h4>
      <p>
        The ESP32 features a built-in deep-sleep mode. Given the application, it
        is unnecessary to sample every second.
        The MCU enters a 20-second deep-sleep interval to improve power efficiency.
      </p>

      <h4>Where the data is going</h4>
      <p>
        Using local Wi-Fi connectivity, the MCU uploads data to the
        <a href="https://thingspeak.mathworks.com/">ThingSpeak API</a>,
        a free-to-use IoT cloud platform.
      </p>

      <h4>Arduino IDE Configuration</h4>
      <pre class="code-block"><p>RadiatorReader.cpp</p>
<code class="language-c">
void setup() {
  /* Doesn't utilise loop(), as reboots after deep-sleep elapsed */
    btStop();
    USE_SERIAL.begin(115200);
    
    WiFi.mode(WIFI_STA);
    WiFi.setTxPower(WIFI_POWER_7dBm);
    
    WiFi.begin(SSID, LAN_PASSWORD);

    // Wait for WiFi connections
    int connection_attempts = 0;
    while (WiFi.status() != WL_CONNECTED)
    {
      if (connection_attempts > 30){
        // WiFi is most-likely turned off. 
        USE_SERIAL.println("[ESP32]: WiFi not on? Beginning Long-Sleep (10min)");
        esp_sleep_enable_timer_wakeup(10*(60 * 1000000));
        esp_deep_sleep_start();
      }
      connection_attempts++;
      delay(1000);
    } 
    
    // Connected To WiFi Signal
    pinMode(2, OUTPUT);
    digitalWrite(2, HIGH);

    // ThingSpeak Config/Init
    ThingSpeak.begin(client);

    // Send Data to ThingSpeak
    sensors.begin();
    sensors.requestTemperatures();
    float val = sensors.getTempCByIndex(0);
    APIHandle(String(val));

    // Go back to sleep
    WiFi.disconnect(true);
    WiFi.mode(WIFI_OFF);

    USE_SERIAL.println("[ESP32]: GoodNight");
    esp_sleep_enable_timer_wakeup(20 * 1000000); // 20 Seconds
    esp_deep_sleep_start();
  }


  void APIHandle(String data) {
    /* Transmit data to ThingSpeak channel */
    if (WiFi.isConnected()) {
      ThingSpeak.writeField(ChannelNumber, FieldN, data, API_KEY);
      delay(100);
    }
  }
</code></pre>

      <img src="Radiator Twin Media/ThingSpeak.png">
    </div>
  </section>
</div>

<div class="main-wrapper">
  <section>
    <div class="timeline">
      <div class="timeline-step">
        <h3>3. Visualisation</h3>
        <h4>Digital Twinning</h4>
        <p>
          Tools such as Simulink and Unreal Engine 5 enable immersive real-time simulations.
          By capturing perceivable variables, the physical system can be replicated digitally.
        </p>

        <h4>Example</h4>
        <img src="Radiator Twin Media/DigitalTwin.png">
      </div>
    </div>
  </section>
</div>



  <div class="main-wrapper">
<strong style="color:yellow">Still Documenting this! :)</strong>

    <section>
      <div class="timeline">
        <div class="timeline-step">
          <h3>4. Prediction</h3>
          <p>
          Most individuals I have spoken to regarding downtime at their respective workplace has shook their heads
          in agreal, regardless of the industrial sector. Any company will improve their productivity & efficiency tremendously,
          if given the ability to accurately anticipate.

          Therefore, a key motivation for adopting an Industry 4.0 solution is smart maintanence strategies such as PdM.
          Industrial IoT being a foundational technology, co-insiding with ML algorithms for acheiving Predictive Maintenance (PdM). PdM is the concept behind
          estimating the Remaining Useful Life (RUL), of a thing. In this scenario, the thing being a radiator & heating, if I could access when exactly the heating 
          is turned on then theoretically, I could take each instance of a heat-up cycle and compare the heat-up latency (from coldest to warmest reached temperature). 
          Detecting a gradually decreasing pattern.
          <br><br>
          For this example, given my current limited setup, I am simply predicting the daily temperature reading. This was achieved harnessing the power 
          of Seasononal Auto-Regressive Intergrated Moving Average (SARIMA). This is done in python 
          <a href="https://github.com/Patrick-Wigley/Data-Statistic-Tools/blob/main/RadiatorForecasting/MA.ipynb">Notebook here ðŸ“’</a> 
          For an brief overview here, the highlights of this is:
          
          Datapoints was collected from Thingspeak cloud & preprocessed using Pandas dataframes.
          <UL>
            <li>
              Removing incorrect initial OneWire reading on power on (Reads 85) 
            </li>
            <li>
              Removing extreme errorneous data
            </li>
            <li>
              Resampling datapoints into strict 10min intervals, using <a href="https://www.geeksforgeeks.org/python/python-pandas-dataframe-resample/">pandas resample method</a> with mean interpolation
            </li>
            <li>
              Removing NaNs & Null values
            </li>
          </UL>
          Boom done. Now the important parts.
          <br>
          <strong>Firstly, we need to explore our data (EDA)</strong>
          We need to test if our data is <a href="https://www.geeksforgeeks.org/python/how-to-check-if-time-series-data-is-stationary-with-python/">stationary</a>. 
          For ARIMA models to work well, the data needs to have no trends nor patterns. But the data needs to have detectable trends to pick up on, contradictory right?
          well... 

          Fortunately, we can test the data using pre-constructed statistical analytical tools such as Augmented Dickey-Fuller (ADF). 
          <img src="Radiator Twin Media/StationaryTest.png">
          Brilliant, our data is clearly very stationary. This can be interpreted as such because, if the ADF score is <= 1%, it conveys 99% confidence the data is stationary. 
          There is no signs of trends. And no detected change with seasons. Remember our model is seasonal, SARIMA retains the scope of cyclic data, such as daily or monthly. In this case, 
          daily radiator temperature fluctations is the goal for prediction. Therefore the seasonal aspect (daily) is fitting. 
<br>
<br>
<br>      
          Auto-Regessive model takes "terms", these are the amount of lags which will influence the current. 
          Using the Partial Autocorrelation Function (PACF), we can see exactly how many previous lags have effect on the current lag.
          This can be determined by reading the number of inital spikes: 
          <img src="Radiator Twin Media/PACF.png">
          The PACF graph tells us that there are 3 significant spikes before the lags fall back into their mean range.

<br>
<br>


<strong>Results</strong><br>
I have produced two graphs in Matplotlib, 1st graph shows the difference between datapoints from the predicted & truth. The deviations from 0 
are indicative of incorrect values. 
<img src="Radiator Twin Media/AccuracyFromTruth.png">
You can see the prediction was quite close in some areas, especially given the 
unpredictable nature of a generic household radiator. The thermostat depends on multiple factors such as arbitrary human intervention, boiler temperature regulator & 
environmental conditions.

<br><br>
<strong>Here is the exciting part! </strong>
<img src="Radiator Twin Media/ForecastComparison.png">
<p style="text-align: center; font-style: italic;">Figure 3. Prediction & Truth Comparison</p>
Close right?!

<code class="language-python"><pre>
</pre></code>



          <!-- I plan to utilise a simplistic statisical technique such as the Moving Average (MA),
          to see if I can get an estimation of the Remaining Useful Life (RUL), by looking at 
          the gradual increase in latency for each instance of a "heat up". 
          <br>
          I am currently experimenting as I plan to utilise data-science & ML techniques to estimate
          the RUL of machinery for my dissertion this year, as part of my undergraduate BSc (hons) Computer Sciences final year project. -->
          <br><br>
          <!-- For this senario, I am simply predicting x. Bare in mind, this is a starting point.
          I have utilised a moving average (MA) ML model to determine y. -->

          
          </p>
          
        </div>
    </section>
  </div>


<footer>
  Â© <span id="year"></span> Radiator Digital Twin Progress
</footer>

<script>
  const modal = document.getElementById("imgModal");
  const modalImg = document.getElementById("modalImg");
  const closeBtn = document.querySelector(".close-btn");

  document.querySelectorAll(".image-box img").forEach(img => {
  img.addEventListener("click", () => {
      modal.style.display = "flex";
      modalImg.src = img.src;
  });
  });

  closeBtn.addEventListener("click", () => {
  modal.style.display = "none";
  });

  modal.addEventListener("click", (e) => {
  if (e.target === modal) {
      modal.style.display = "none";
  }
  });

  document.getElementById("year").textContent = new Date().getFullYear();
</script>

</body>
</html>

